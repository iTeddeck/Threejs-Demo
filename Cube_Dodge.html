<!doctype html>
<html lang="en">
<head>
    <title>Keyboard Input (Three.js)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>

<audio id="audiotag1" src="sounds/06 Far Horizons.mp3" preload="auto"></audio>
<audio id="multiaudio1" preload="auto" src="sounds/10 One They Fear.mp3"></audio>
<a href="javascript:play_single_sound();">Play 5-sec sound on single channel</a>
<script type="text/javascript">
	function play_single_sound() {
		document.getElementById('audiotag1').play();
	}
</script>

<!-- Code to display an information button and box when clicked. -->
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<link rel=stylesheet href="css/info.css"/>
<script src="js/info.js"></script>
<div id="infoButton"></div>
<div id="infoBox" title="Demo Information">
Controls: Press A/D to move continuously, press LEFT/RIGHT to move in discrete jumps,
and press R to change color (will return to original color when key is released).
<br/><br/>
This three.js demo is part of a collection at
<a href="http://stemkoski.github.io/Three.js/">http://stemkoski.github.io/Three.js/</a>
</div>
<!-- ------------------------------------------------------------ -->

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: August 2013 (three.js v60)
 */

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var clock = new THREE.Clock();

var keyboard = new KeyboardState();

// custom global variables
var mesh;
var cubes = [];

var BLOCK_Y_POS = 25.1;


var arrowList = [];
var directionList = [];

init();
animate();

// FUNCTIONS
function init()
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 90, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(0,50,400);
	camera.lookAt(scene.position);
	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer();
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS
	THREEx.WindowResize(renderer, camera);
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	// STATS
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );
	// LIGHT
	var light = new THREE.PointLight(0xffffff);
	light.position.set(100,250,100);
	scene.add(light);
	// FLOOR
	var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -0.5;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);
	// SKYBOX
	var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
	scene.add(skyBox);

	////////////
	// CUSTOM //
	////////////

	var makeCube = function (cWidth, cHeight, cDepth, xPos, yPos, zPos, movVal) {
		var hitBlueBlock = false;
		var hitOtherSide = false;
    var delta = clock.getDelta();
    var moveDistance = 200 * delta;
    var mov = movVal;

    var materialArray = [];
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/xpos.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/xneg.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/ypos.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/yneg.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/zpos.png' ) }));
		materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/zneg.png' ) }));
    var MovingCubeMat = new THREE.MeshFaceMaterial(materialArray);
    var MovingCubeGeom = new THREE.CubeGeometry( cWidth, cHeight, cDepth, 1, 1, 1, materialArray );
		mc = new THREE.Mesh( MovingCubeGeom, MovingCubeMat );
		mc.position.set(xPos, BLOCK_Y_POS, zPos); // -200, 25.1, -400
		scene.add( mc );


    mc.setPos = function(newX, newY, newZ) {
			this.position.x = newX;
			this.position.y = newY;
			this.position.z = newZ;
		}

    mc.move = function() {
			this.position.z += moveDistance + mov;

			if ( this.position.z > 500) {
        var xRand = Math.floor(Math.random()*400 - 200);
        var yRand = Math.floor(Math.random()*200 + 25.1);
        this.setPos(xRand, yRand, 0);
			}

			if ( this.position.z < -400) {
				hitOtherSide = false;
				if (hitBlueBlock == false) {
					moveDistance *= -1;
					mov *= -1;
					hitBlueBlock = true;
				}
			}
		}

		mc.bounceBack = function() {
			if (hitOtherSide == false) {
				hitBlueBlock = false
				moveDistance *= -1;
				mov *= -1;
				hitOtherSide = true;
			}
		}

    return mc;
	}

	// ADDING CUBES
  cubes.push(makeCube(50, 50, 50, 0, BLOCK_Y_POS, -400, 5));
  cubes.push(makeCube(50, 50, 50, 100, BLOCK_Y_POS, -400, 6));
  cubes.push(makeCube(50, 50, 50, -100, BLOCK_Y_POS, -400, 7));
  cubes.push(makeCube(50, 50, 50, 200, BLOCK_Y_POS, -400, 8));
  cubes.push(makeCube(50, 50, 50, -200, BLOCK_Y_POS, -400, 9));

	// SOUND
	play_single_sound();

	var channel_max = 5;	// number of channels
	audiochannels = new Array();
	for (a=0;a<channel_max;a++) {	// prepare the channels
		audiochannels[a] = new Array();
		audiochannels[a]['channel'] = new Audio();	// create a new audio object
		audiochannels[a]['finished'] = -1;	// expected end time for this channel
	}

	// BLOCK OBJECT
	var blockGeometry = new THREE.CubeGeometry( 120, 40, 20, 1, 1, 1 );
	var blockMaterial = new THREE.MeshBasicMaterial( {color: 0x0000ff, transparent: true, opacity: 0.5} );
	blockW = new THREE.Mesh(blockGeometry, blockMaterial);
	blockW.position.set(0, 0, -100);
  camera.add(blockW);


}

// SOUND
function play_multi_sound(s) {
	for (a=0;a<audiochannels.length;a++) {
		thistime = new Date();
		if (audiochannels[a]['finished'] < thistime.getTime()) {			// is this channel finished?
			audiochannels[a]['finished'] = thistime.getTime() + document.getElementById(s).duration*1000;
			audiochannels[a]['channel'].src = document.getElementById(s).src;
			audiochannels[a]['channel'].load();
			audiochannels[a]['channel'].play();
			break;
		}
	}
}

function animate()
{
  requestAnimationFrame( animate );
	render();
	update();
}

function update()
{
	keyboard.update();

	// KEYBOARD CONTROL
	if ( keyboard.pressed("up") ) {
		camera.position.y += 10;
	}
	if ( keyboard.pressed("down") ) {
		if (camera.position.y > 50) {
			camera.position.y -= 10;
		}
	}
	if ( keyboard.pressed("right") ) {
		camera.position.x += 10;
	}
	if ( keyboard.pressed("left") ) {
		camera.position.x -= 10;
	}

	// CUBE MOVEMENT
  cubes.forEach(function (cube) {
    cube.move();
  })


	// COLLISION DETECTION
	var originPoint = blockW.position.clone();
  blockW.localToWorld(originPoint);
	for (var vertexIndex = 0; vertexIndex < blockW.geometry.vertices.length; vertexIndex++)
	{
		var localVertex = blockW.geometry.vertices[vertexIndex].clone();
		var globalVertex = localVertex.applyMatrix4( blockW.matrix );
		var directionVector = globalVertex.sub( blockW.position );

		var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
    var collisionResults = ray.intersectObjects( cubes );
    var i = 0;
    collisionResults.forEach(function(collided) {
      if ( collided.distance < directionVector.length()) {
        collided.object.bounceBack();
        //play_multi_sound('multiaudio1');
      }
    })

	}
	stats.update();
}

function render()
{
	renderer.render( scene, camera );
}

</script>

</body>
</html>
